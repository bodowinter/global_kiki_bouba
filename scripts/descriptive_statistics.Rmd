---
title: "Descriptive stats for kiki/bouba experiments (field + web)"
author: "Bodo Winter"
date: "7/30/2019"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

This is script performs descriptive statistics of the online data and the field work experiment.

Note on the field experiment:
The field work experiment is not reported in the main analysis. We do find a clear kiki/bouba effect in the field work data, however, there was a critical error in the procedure: the written version was always run before the spoken version. As a result of this, the spoken versus written comparison is not interpretable, as the spoken results could be biased by having seen a prior orthographic representation. Moreover, the web experiment and the field experiment are thus not comparable anymore.

## Load in data

Load packages:

```{r, message = FALSE, warning = FALSE}
library(tidyverse)
library(lsr)    # For calculating Cramer's V 
library(gridExtra)

# For mapping:

library(sf)
library(ggpubr)
library(rnaturalearth)
library(rnaturalearthdata)
```

Load data:

```{r, message = FALSE, warning = FALSE}
kiki <- read_csv('../data/web_experiment_cleaned.csv')
field <- read_csv('../data/field_experiment_cleaned.csv')

# Marcus's newly recoded L2 data:

L2 <- read_csv('../data/english_recoded.csv')
```

Load ggplot2 theme:

```{r}
source('theme_timo.R')
```

## Overall stats:

How may speakers?

```{r}
# Web experiment:

length(unique(kiki$ID))

# Field experiment:

length(unique(field$ID))
```

How many languages?

```{r}
# Web experiment:

length(unique(kiki$Language))

# Field experiment:

length(unique(field$Language))
```

Total number of languages across experiments?

```{r}
# Minus German, English, Portuguese, which are counted doubly as they occur in both:

length(unique(kiki$Language)) + length(unique(field$Language)) - 3
```

How many language families?

```{r}
# +1 with field data because Palikur from the field data is Arawakan, which is a language family that is not in the web data

length(unique(kiki$Family))
```

How many Indo-European languages?

```{r}
unique(filter(kiki, Family == 'IE')$Name)
length(unique(filter(kiki, Family == 'IE')$Name))
```

What are the non-Indo-European language families?

```{r}
unique(filter(kiki, Family != 'IE')$Family)
```

How many per language?

```{r}
# Web experiment:

table(filter(kiki, !duplicated(ID))$Language)

# Field experiment:

table(filter(field, !duplicated(ID))$Language)
```

How many languages that have non-Roman scripts?

```{r}
unique(kiki[kiki$Script != 'roman', ]$Name)
length(unique(kiki[kiki$Script != 'roman', ]$Language))

# How many of the total is that?

length(unique(kiki[kiki$Script != 'roman', ]$Language)) / length(unique(kiki$Language))
```

9 languages out of 24, more than a third, have non-Roman scripts.

Check first language categories of L2 speakers that indicate to be L1 (see whether everything has been correctly coded):

```{r}
filter(kiki, English_MP == 'L1')$Language
```

There is a German and a French speaker that according to Marcus's recording of the L1/L2 info are wrongly coded as German/French. These arae English natives living in Germany / France who have filled out the German / French version of the survey.

```{r}
kiki[which(kiki$English_MP == 'L1' & kiki$Language == 'DE'), ]$Language <- 'EN'
kiki[which(kiki$English_MP == 'L1' & kiki$Language == 'FR'), ]$Language <- 'EN'
```

How many per L2 category?

```{r}
kiki %>% count(English_MP) %>% mutate(Prop = n / sum(n),
                                      Prop = round(Prop, 2))
```

## The first five participants in the field experiment have been wrongly coded:

Email from Ola Feb 10, 2020 indicates that the first five participants in the German data of the field experiment have been erroneously coded as mismatches (0), even though they were matches:

```{r}
these_ppts <- str_c('DE0', 1:5)
field[field$ID %in% these_ppts & !is.na(field$Match), ]$Match <- 1
```

Write this:

```{r}
write_csv(field, '../data/field_experiment_cleaned.csv')
```

## Web experiment:

Check the overall proportion of matches:

```{r}
round(mean(kiki$Match, na.rm = TRUE), 2)
```

Overall 71% matching the hypothesis (that "kiki" input = kiki shape, and "bouba" input = bouba shape).

Check this for the different L2:

```{r}
kiki %>% group_by(English_MP) %>% 
  summarize(Match = round(mean(Match, na.rm = TRUE), 2)) %>% 
  arrange(Match)
```

Check this for the different languages in separate mini tables:

```{r}
lang_tab <- kiki %>%
  group_by(Language, Name, Family, Script) %>%
  summarize(Match = mean(Match), Match = round(Match, 2))

lang_tab <- kiki %>% count(Language) %>% right_join(lang_tab)

lang_tab <- lang_tab %>% 
  arrange(desc(Match))

lang_tab %>% 
  print(n = Inf)
```

Get the average proportions by script:

```{r}
kiki %>% group_by(Script) %>% 
  summarize(Match = mean(Match))
```

Make a plot of this:

```{r, fig.width = 12, fig.height = 6}
lang_tab %>%
  ggplot(aes(x = reorder(Language, Match),
             y = Match, fill = Script)) +
  geom_col() +
  labs(x = '', y = 'Proportion\n') +
  ggtitle('Proportion match by language') + 
  coord_cartesian(ylim = c(0, 1)) + 
  geom_hline(yintercept = 0.5, linetype = 2, size = 2) + 
  scale_fill_viridis_d(option = 'D', begin = 0.3, end = 0.8) +
  theme_timo
```

This suggests that languages with different scripts on average seem to have less strong of a kiki/bouba effect. Of course, that's partially confounded with genealogical associations since languages with different scripts are more likely non-Indo-European.

Create a variable for IE versus non-IE:

```{r}
lang_tab <- mutate(lang_tab,
                   `Language Family` = ifelse(Family == 'IE', 'IE', 'other'))
```

Change the script label so it's nice for plotting:

```{r}
lang_tab <- mutate(lang_tab,
                   Script = ifelse(Script == 'roman', 'Roman script', 'non-Roman script'))
```

Make a plot broken up by IE versus non-IE:

```{r, fig.width = 12, fig.height = 12}
# Aesthetics:

web_p <- lang_tab %>%
  ggplot(aes(x = reorder(Name, Match),
             y = Match, fill = Script))

# Geoms:

web_p <- web_p +
  geom_bar(stat = 'identity', width = 0.7) +
  geom_hline(yintercept = 0.5, linetype = 2, size = 2)

# Extra stuff:

web_p <- web_p + 
  labs(x = '', y = 'Proportion\n') +
  ggtitle('(a) Web experiment') + 
  coord_cartesian(ylim = c(0, 1)) + 
  scale_fill_viridis_d(option = 'D', begin = 0.3, end = 0.8, direction = 1) +
  theme_timo +
  theme(axis.text.x = element_text(angle = 45, hjust = 1, face = 'bold', size = 24),
        axis.text.y = element_text(face = 'bold', size = 24),
        axis.title = element_text(face = 'bold', size = 40),
        axis.title.y = element_text(face = 'bold', size = 40),
        plot.title = element_text(face = 'bold', size = 40,
                                  margin = margin(t = 0, r = 0,
                                                  b = 20, l = 0)),
        legend.text = element_text(size = 24),
        legend.title = element_text(size = 32, face = 'bold'))

# Show:

web_p
```

Write the table with only those that clearly have 'no' for L2 English, for Bayesian analysis:

```{r}
no_english <- filter(kiki, English_MP == 'no')
write_csv(no_english, 'web_experiment_cleaned_no_english.csv')
```

## Field experiment:

For the field experiment, we had the planning issue that in all cases except Daakie, the written experiment was run first. This makes this data not open to testing the idea that there is a genuine effect of spoken iconicity, as the spoken responses are contaminated because of having seen the spiky and round letters first.

Because of this, we are only going to look at Daakie for the analysis reported in the paper.

It should be noted that the results from the other languages do support the kiki/bouba effect, but only the ritten version 

Let's get only the Daakie data points:

```{r}
field_red <- filter(field, Language == 'VA', Modality == 'Aud')
```

First, overall match:

```{r}
str_c(round(mean(field_red$Match), 3) * 100, '%')
```

This is such little data, let's make a table:

```{r}
table(field_red$Match)
```

Write this to table for Bayesian analysis:

```{r}
write_csv(field_red, '../data/field_daakie_only.csv')
```

## Analysis of the remaining data (not reported in paper):

First, overall match:

```{r}
mean(field$Match, na.rm = TRUE)
```

Check result depending on whether modality was auditory or written (aggregating across languages and speakers):

```{r}
field %>% group_by(Modality) %>% 
  summarize(Match = mean(Match, na.rm = TRUE))
```

Not much going on here. A mere 3% difference.

For various reasons, we want to focus on the spoken version of the task. This is also because it was always run first.

```{r}
field <- filter(field, Modality == 'Aud')
```

Check results by languages:

```{r}
field_lang_tab <- field %>% 
  group_by(Language) %>%
  summarize(Match = mean(Match, na.rm = TRUE),
            Match = round(Match, 2))

field_lang_tab <- field %>% count(Language) %>% right_join(field_lang_tab)

field_lang_tab <- field_lang_tab %>% 
  arrange(desc(Match))

field_lang_tab
```

For plot, create full language names:

```{r}
field_lang_tab$Name <- c('British English',
                         'Tashlhiyt Berber',
                         'German',
                         'Daakie',
                         'Palikur',
                         'Brazilian Portuguese')
```

Make a plot of this:

```{r, fig.width = 12, fig.height = 6}
# Aesthetics:

field_p <- field_lang_tab %>%
  ggplot(aes(x = reorder(Name, Match),
             y = Match))

# Geoms:

field_p <- field_p + 
  geom_bar(fill = 'gray42', stat = 'identity', width = 0.8)

# Extra stuff:

field_p <- field_p +
  labs(x = '', y = 'Proportion\n') +
  ggtitle('(b) Field experiment') +
  coord_cartesian(ylim = c(0, 1)) + 
  geom_hline(yintercept = 0.5, linetype = 2, size = 2) + 
  theme_timo +
  theme(axis.text.x = element_text(angle = 45, hjust = 1, face = 'bold', size = 24),
        axis.text.y = element_text(face = 'bold', size = 24),
        axis.title = element_text(face = 'bold', size = 40),
        axis.title.y = element_text(face = 'bold', size = 40),
        legend.position = 'none',
        plot.title = element_text(face = 'bold', size = 40,
                                  margin = margin(t = 0, r = 0,
                                                  b = 20, l = 0)))

# Plot:

field_p
```

## Combine both plots:

First, create a layout matrix:

```{r}
my_layout <- rbind(c(1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1),
                   c(1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1),
                   c(1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1),
                   c(1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1),
                   c(1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1),
                   c(1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1),
                   c(1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1),
                   c(NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA),
                   c(2, 2, 2, 2, 2, 2, NA, NA, NA, NA, NA),
                   c(2, 2, 2, 2, 2, 2, NA, NA, NA, NA, NA),
                   c(2, 2, 2, 2, 2, 2, NA, NA, NA, NA, NA),
                   c(2, 2, 2, 2, 2, 2, NA, NA, NA, NA, NA),
                   c(2, 2, 2, 2, 2, 2, NA, NA, NA, NA, NA),
                   c(2, 2, 2, 2, 2, 2, NA, NA, NA, NA, NA))
```

Then, create the double plot:

```{r, fig.width = 14, fig.height = 10}
multi_plot <- grid.arrange(web_p, field_p,
                           layout_matrix = my_layout)
ggsave(plot = multi_plot, '../figures/per_language_barplots.png', width = 24, height = 20)
ggsave(plot = multi_plot, '../figures/per_language_barplots.pdf', width = 24, height = 20)
```

This completes this analysis.

## Plot of the world map:

Load country-level data:

```{r, message = FALSE, warning = FALSE}
web_countries <- read_csv('../data/countries_map_online.csv')

# From: https://developers.google.com/public-data/docs/canonical/countries_csv

canonical <- read_csv('../data/countries.csv')
```

Merge the longitude and latitude info in there:

```{r}
web_countries <- left_join(web_countries, canonical,
                           by = c('CountryCode' = 'country'))
```

Make a map:

```{r, fig.width = 9, fig.height = 6}
world <- ne_countries(scale = "medium", returnclass = "sf")

world_p <- ggplot(world) +
  geom_sf(size=0.2) +
  coord_sf(xlim = c(-180, 180), ylim = c(-60, 80), datum=NA) +
  geom_point(data = web_countries,
             aes(x = longitude, y = latitude, group = NA),
             alpha = 0.8, position = position_jitter(0.1), size = 3,
             col = 'firebrick1') +
  labs(title = "Countries from the participants of our web survey") +
  theme_timo +
  theme(
    axis.title = element_blank(),
    axis.text = element_blank(),
    axis.line = element_blank(),
    axis.ticks = element_blank(),
    plot.margin = unit(c(0.1,0.4,-0.4,0.4),"cm"),
    panel.spacing = unit(0, "lines"),
    plot.title = element_text(size = 12))

# Plot:

world_p

# Save:

ggsave('../figures/Figure2_world_map.pdf', plot = world_p)
```



